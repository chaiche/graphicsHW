<!DOCTYPE html>

<html>

<head>
<style>
body {
    background-color: #fff;
    color: #111;
    margin: 0px;
    overflow: hidden;
    font-family: Monospace;
    font-size: 10px;
    position: absolute;
}
#info {
    position: absolute;
    top: 3%;
    width: 100%;
    padding: 5px;
    text-align: center;
    color: #ffff00
}

</style>
</head>

<body> 

<div id="info">Render to Texture
<br> hw7: monochrome
<br> I want to add a colored focus
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r76/three.min.js"></script>
<script src="https://dl.dropboxusercontent.com/u/3587259/Code/Threejs/OrbitControls.js">
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
    
<script id="myVertexShader" type="x-shader/x-vertex">
  varying vec2 vUv;
  void main() {
    gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0);
    vUv = uv;
  }
</script>
<script id="myFragmentShader" type="x-shader/x-fragment">
  uniform sampler2D texture;
  uniform float fade;
  varying vec2 vUv;
vec3 rgb2hsv(vec3 c)
{
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
} 
  void main() {
    vec4 color = texture2D (texture, vUv);
    vec3 hsv = rgb2hsv (color.rgb);
    hsv.y = fade;
    vec3 rgb = hsv2rgb (hsv.xyz);
    gl_FragColor = vec4 (rgb, 1.0);
  }
</script>
<script type="text/javascript">
var renderer, camera, controls;
var pointLight;
var scene, sceneRTT, rtTexture, torus;
var rttmaterial, quad;
var camera2;
var quads = [];
var Plane = function (mesh,x) {
    this.mesh = mesh;
    this.turn = false;
    this.fadevalue = 0.0;
    this.x = x;
};
Plane.prototype.update = function (x) {
    if (this.turn) {
    console.log('1');
       this.mesh.material.uniforms.fade.value = (5.0-this.fadevalue)/5.0;
       if(this.fadevalue<5.0)this.fadevalue+=0.01;
    }
    else{
      if(this.x < x) this.turn =true;
    }
};

init();
animate();


function init()
{
  
  rtTexture = new THREE.WebGLRenderTarget( 
    1024,1024,
    { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat } 
    );
  rtTexture2 = new THREE.WebGLRenderTarget( 
    1024,1024,
    { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat } 
    );

  renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize (window.innerWidth, window.innerHeight);
  document.body.appendChild (renderer.domElement);
  renderer.setClearColor (0x888888);
  renderer.autoClear = false;
  
  camera = new THREE.PerspectiveCamera (45, window.innerWidth/window.innerHeight, 0.1, 10000);
  camera.position.y = 0;
  camera.position.z = 400;
  camera.lookAt (new THREE.Vector3(0,0,0));

  camera2 = camera.clone();
  // add control here (after the camera is defined)
  controls = new THREE.OrbitControls (camera, renderer.domElement);
//////////////////////////////////////////////////////////////////////////
  // render a torus to texture
  // then apply the texture to a quad,
  // with a monochrome filter
  
  sceneRTT = new THREE.Scene(); 
  pointLight = new THREE.PointLight (0xffffff);
  pointLight.position.set (0,300,200);
  sceneRTT.add (pointLight);

  torus = new THREE.Mesh (new THREE.TorusGeometry(10, 3, 16, 100),
  new THREE.MeshLambertMaterial({color:0xff1234}));
  torus.scale.set (10,10,10);
  torus.rotation.x = Math.PI/2;
  sceneRTT.add (torus);
  
  column1 = new THREE.Mesh(new THREE.BoxGeometry(40, 40, 40),
    new THREE.MeshLambertMaterial({
      color: 0x00f2f2
    }));
  column1.position.set(100,-15,100);
  sceneRTT.add(column1);

  column2 = column1.clone();
  column2.position.set(100,-15,-100);
  sceneRTT.add(column2);

  column3 = column1.clone();
  column3.position.set(-100,-15,-100);
  sceneRTT.add(column3);

  column4 = column1.clone();
  column4.position.set(-100,-15,100);
  sceneRTT.add(column4);
 
  scene = new THREE.Scene();
  rttmaterial = new THREE.ShaderMaterial( {
    uniforms: {
      texture: {type: "t", value: rtTexture},
      fade: {type: "f", value: 3.0},
    },
    vertexShader: document.getElementById( 'myVertexShader' ).textContent,
    fragmentShader: document.getElementById( 'myFragmentShader' ).textContent}
    
    );
  rttmaterial.side = THREE.DoubleSide;
  
 
  var plane = new THREE.PlaneGeometry( 500,500 );
  quad = new THREE.Mesh (plane, rttmaterial);

  scene.add (quad);
  quads.push(new Plane(quad,-200));
  
  quad2 = quad.clone();
  quad2.position.x = 500;
  scene.add (quad2);
 
  quads.push(new Plane(quad,300));
  
  console.log(quads.length);
  column = new THREE.Mesh(new THREE.BoxGeometry(20, 50, 20),
    new THREE.MeshBasicMaterial({
      color: 0xff1234
    }));
  scene.add(column);
  
  
  color={
    fade: 0.5,
  }
  var gui = new dat.GUI();
  gui.add( color, 'fade',0.0,5.0); 
}

window.onresize = function () {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize (window.innerWidth, window.innerHeight);
}

function animate()
{
  controls.update();
  
  requestAnimationFrame ( animate );
  
  rttmaterial.uniforms.fade.value = (5.0-color.fade)/5.0;
  
  //if(column.position.x < 500) column.position.x +=1;
  //update(column.position.x);
  
  //camera.position.copy(column.position);
  //camera.position.z = 400;
  //camera.lookAt(column.position);
  renderer.clear();
  renderer.setClearColor (0x888800);
  
  renderer.render (sceneRTT, camera, rtTexture,true);
  
  renderer.setClearColor (0x008888);
  renderer.render (scene, camera2);
  
  // rtTexture2 has monochorme torus
  // render a board with a monochomre background
  // render to depth buffer (no color), the scene
  // render the colored inside cylinder.
  //?? can I disable color buffer output
  //renderer.render (sceneFinal, camera);

}
function update(x) {
  for (var i = 0; i < quads.length; i++) {
    quads[i].update(x);
  }
}
</script>

</body>

</html>
